#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<malloc.h>
#define MaxSize 100
typedef char ElemType;
typedef struct node
{
	ElemType data;			//数据元素
	struct node* lchild;	//指向左孩子结点
	struct node* rchild;	//指向右孩子结点
} BTNode;

void CreateBTNode(BTNode*& b, const ElemType* str)
{
	BTNode* St[MaxSize], * p = NULL;
	int top = -1, k, j = 0;
	char ch;
	b = NULL;				//建立的二叉树初始时为空
	ch = str[j];
	while (ch != '\0')  	//str未扫描完时循环
	{
		switch (ch)
		{
		case '(':top++; St[top] = p; k = 1; break;		//为左孩子结点
		case ')':top--; break;
		case ',':k = 2; break;                      		//为孩子结点右结点
		default:p = (BTNode*)malloc(sizeof(BTNode));
			p->data = ch; p->lchild = p->rchild = NULL;
			if (b == NULL)                    	 	//*p为二叉树的根结点
				b = p;
			else  								//已建立二叉树根结点
			{
				switch (k)
				{
				case 1:St[top]->lchild = p; break;
				case 2:St[top]->rchild = p; break;
				}
			}
		}
		j++;
		ch = str[j];
	}
}
BTNode* FindNode(BTNode* b, ElemType x)
{
	BTNode* p;
	if (b == NULL)
		return NULL;
	else if (b->data == x)
		return b;
	else
	{
		p = FindNode(b->lchild, x);
		if (p != NULL)
			return p;
		else
			return FindNode(b->rchild, x);
	}
}

int BTNodeHeight(BTNode* b)
{
	int lchild, rchild;
	if (b == NULL)
		return 0;       	//空树的高度为0
	else
	{
		lchild = BTNodeHeight(b->lchild);	//求左子树的高度为lchildh
		rchild = BTNodeHeight(b->rchild);	//求右子树的高度为rchildh
		return(lchild > rchild) ? (lchild + 1) : (rchild + 1);
	}
}

int LeafNodes(BTNode* b)
{
	int l, r;
	if (b == NULL) return 0;//空树返回0
	else
	{
		l = LeafNodes(b->lchild);
		r = LeafNodes(b->rchild);
		return (l + r + 1);
	}
}

void InOrderTraverse(BTNode* T)
{
	if (T != NULL)
	{
		InOrderTraverse(T->lchild); /*递归访问左子树*/
		printf("%c", T->data);
		InOrderTraverse(T->rchild);   /*递归访问右子树*/
	}
}
void LevelTraverse(BTNode* T)
{
	BTNode* p;
	BTNode* qu[MaxSize];	/*定义环形队列,存放结点指针*/
	int front, rear;	        /*定义队头和队尾指针*/
	front = rear = -1;	     	/*置队列为空队列*/
	rear++;
	qu[rear] = T;		       /*根结点指针进入队列*/
	while (front != rear)	  /*队列不为空*/
	{
		front = (front + 1) % MaxSize;
		p = qu[front];	/*队头出队列*/
		printf("%c", p->data);
		if (p->lchild != NULL)	/*有左孩子时将其进队*/
		{
			rear = (rear + 1) % MaxSize;
			qu[rear] = p->lchild;
		}
		if (p->rchild != NULL)	/*有右孩子时将其进队*/
		{
			rear = (rear + 1) % MaxSize;
			qu[rear] = p->rchild;
		}
	}
}

int InOrderNRe(BTNode* b)
{
	BTNode* St[MaxSize], * q;
	int top = -1;
	if (b == NULL) return 0;
	while (top > -1 || b != NULL)
	{
		while (b != NULL)
		{
			top++; St[top] = b;
			b = b->lchild;
		}
		q = St[top]; top--;
		printf("%c", q->data);
		if (q->rchild != NULL)
			b = q->rchild;
	}
	return 0;

}

void PrintBTNode(BTNode* root, int level)
{//二叉树root第level层结点数据元素值的横向输出
	if (root != NULL)
	{//子二叉树root.getRight()第level+1层结点数据元素值的横向输出
		PrintBTNode(root->rchild, level + 1);
		if (level != 0)
		{//走过6*(level-1)个空格
			for (int i = 0; i < 4 * (level - 1); i++)
			{
				printf("%s", " ");
			}
			printf("%s", "---");		//输出横线
		}
		printf("%c", root->data); 		//输出结点的数据元素值
		printf("\n");
		//子二叉树root.getLeft()第level+1层结点数据元素值的横向输出
		PrintBTNode(root->lchild, level + 1);
	}
}

int main()
{
	BTNode* b;
	printf("(1)根据二叉树的广义表表示法创建二叉树的链式存储结构");
	CreateBTNode(b, "1(2,3(4(6),5))");
	printf("(2)二叉树的横向输出为:\n");
	PrintBTNode(b, 0);
	BTNode* F;
	printf("\n(3)查找二叉树中的给定值的结点,例如定值点3");
	F = FindNode(b, '3');
	printf("左孩子为:%c, 右孩子为:%c", F->lchild->data, F->rchild->data);
	printf("\n(4)二叉树的高度的高度为:%d\n", BTNodeHeight(b));
	printf("(5)二叉树中的节点个数的为:%d", LeafNodes(b));
	printf("\n(6)二叉树的中序遍历为:");
	InOrderTraverse(b);
	printf("\n(7)二叉树的层序遍历为:");
	LevelTraverse(b);
	printf("\n(8)二叉树的非递归遍历(中序遍历):");
	InOrderNRe(b);
	printf("\n");

}